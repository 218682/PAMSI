/*!
\file
\brief plik zawiera klase lista2, ktora jest zbudowana jak klasyczna lista
*/
#ifndef LISTA2s_HH
#define LISTA2s_HH
#include "inlista.hh"
#include "strukturalistyT.hh"
#include <string>
template <class typ>
class lista2s{
protected:
  StrListyT <typ> *FIRST;
  int rozmiar;
public:
  //! konstruktor bezparametryczny
  lista2s();
  void remove(int);
  void remove();
  void add(typ , int);
  void add(typ);
  typ get (int);
  bool isEmpty();
  int find(typ);
  class bad_index{};
  class empty{};
};


//-------------------------------------------------//
template <class typ>
void lista2s<typ>::add(std::string x)  
{
  StrListyT <typ> *NEW  = new StrListyT<typ>;
  NEW->dana=x;
  NEW->NEXT=FIRST;
  FIRST=NEW;
  rozmiar++;
  }
//-------------------------------------------------//
template <class typ>
void lista2s<typ>::add(typ x, int index)
{
  if(index==rozmiar)
    add(x);
  else if(index<rozmiar)
    {
      StrListyT <typ> *NEW = new StrListyT <typ>;
      StrListyT <typ> *tmp = FIRST;
      NEW=FIRST;
      for(int j=0; j+1!=index; j++)//przeskakiwanie do odpowiedniego elementu
	tmp = tmp->NEXT;
      NEW->dana=x;
      NEW->NEXT=tmp;
      tmp->NEXT=NEW;
      rozmiar++;
    }
  else
    throw bad_index();
    }
//-------------------------------------------------//
template <class typ>
void lista2s<typ>::remove(int i)
{
  if(rozmiar==0)
    throw empty();
  else if(i>rozmiar)
    throw bad_index();
  else
    {
      StrListyT <typ> *tmp = FIRST;
      if(i==0)
	{
	  FIRST=tmp->NEXT;
	  delete tmp;
	}
      else if(i>=1)
	{
	  for(int j=0; tmp && j+1!=i; j++)
	    tmp = tmp->NEXT;          //przeskakiwanie do odpowiedniego elementu
	  if (tmp->NEXT->NEXT==NULL)
	    {
	      delete tmp->NEXT;
	      tmp->NEXT=NULL;
	    }
	  else
	    {
	      delete tmp->NEXT; //zwalnianie pamieci
	      tmp->NEXT=tmp->NEXT->NEXT;
	    }
	}
      rozmiar--;
    }
}
//-------------------------------------------------//
template <class typ>
void lista2s<typ>::remove()
{
  
  if(rozmiar==0)
    throw empty();
  else
    {
      StrListyT <typ> *tmp = FIRST;
      FIRST=tmp->NEXT;
      delete tmp;         //zwalnianie pamieci
      /*for(int j=0; tmp && j+1!=rozmiar; j++)
      tmp = tmp->NEXT;              //przeskakiwanie do odpowiedniego elementu
      delete tmp->NEXT;             //zwalnianie pamieci
      tmp->NEXT=NULL;*/
      rozmiar--;
    }
}
//-------------------------------------------------//
template <class typ>
std::string lista2s<typ>::get(int i)
{
  if(rozmiar==0)
    throw empty();
  else if (i>rozmiar || i<0)
    throw bad_index();
  else
    {
      StrListyT <typ> *tmp = FIRST;
      for(int j=0; j!=i; j++)
	tmp = tmp->NEXT;              //przeskakiwanie do odpowiedniego elementu
      return tmp->dana;
    }
}
//-------------------------------------------------//
template <class typ>
bool lista2s<typ>::isEmpty()
{
  if(rozmiar==0)
    return true;
  else return false;
}
//-------------------------------------------------//
template <class typ>
int lista2s<typ>::size()
{
  return rozmiar;
}
//-------------------------------------------------//
template <class typ>
int lista2s<typ>::find(typ x)
{
  if(rozmiar==0)
    throw empty();
  else
    {
      int j=0;
      StrListyT <typ> *tmp = FIRST;
      for(j=0; tmp->dana!=x && tmp->NEXT!=NULL; j++)
	tmp = tmp->NEXT;              //przeskakiwanie do odpowiedniego elementu
      if (tmp->NEXT!=NULL)
	return j;
      else
	throw empty();
    }
}

#endif
